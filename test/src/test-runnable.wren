import "timer" for Timer
import "src/matchers" for Expect
import "src/suite" for Suite

import "src/expectation" for Expectation

// Module under test.
import "src/runnable" for Runnable

var TestRunnable = Suite.new("Runnable") { |it|
  it.should("wrap a bare function") {
    var runnable = Runnable.new("Test", [], []) {
      return Expectation.new(true, "Fail")
    }

    var result = runnable.run()

    Expect.call(result.count).toEqual(1)
    Expect.call(result[0].passed).toBeTrue
    Expect.call(result[0].message).toEqual("Fail")
  }

  it.should("not return values yielded that aren't Expectation") {
    var testFiber = Fiber.new {
      Fiber.yield(1)
    }
    var runnable = Runnable.new("Test", [], [], testFiber)

    Expect.call(runnable.run().count).toEqual(0)
  }

  it.should("return all expectations emitted by the function") {
    var testFiber = Fiber.new {
      Fiber.yield(Expectation.new(true, "First"))

      // Yield a value that isn't an Expectation.
      Fiber.yield(false)

      Fiber.yield(Expectation.new(false, "Second"))
    }
    var runnable = Runnable.new("Test", [], [], testFiber)

    var result = runnable.run()

    Expect.call(result[0].passed).toBeTrue
    Expect.call(result[0].message).toEqual("First")
    Expect.call(result[1].passed).toBeFalse
    Expect.call(result[1].message).toEqual("Second")
  }

  it.suite("beforeEach & afterEach") { |it|
    it.should("call beforeEach functions") {
      var value = 0

      var beforeEach = Fn.new {
        value = 1
      }

      var runnable = Runnable.new("Test", [beforeEach], []) {
        Fiber.yield(Expectation.new(true, value.toString))
      }

      var result = runnable.run()

      Expect.call(result[0].passed).toBeTrue
      Expect.call(result[0].message).toEqual("1")
    }

    it.should("call afterEach functions") {
      var value = 0

      var afterEach = Fn.new {
        value = 1
      }

      var runnable = Runnable.new("Test", [], [afterEach]) {
        Fiber.yield(Expectation.new(value == 0, value.toString))
      }

      var result = runnable.run()

      Expect.call(value).toEqual(1)
      Expect.call(result[0].passed).toBeTrue
      Expect.call(result[0].message).toEqual("0")
    }
  }

  it.suite("public getters") { |it|
    it.should("return the title") {
      var runnable = Runnable.new("Test Title", [], []) {}

      Expect.call(runnable.title).toEqual("Test Title")
    }

    it.should("return the duration of a test run") {
      var runnable = Runnable.new("Test", [], []) {
        Timer.sleep(50)
      }
      runnable.run()

      Expect.call(runnable.duration > 0).toBeTrue
    }

    it.should("correctly say if the runnable has been run") {
      var runnable = Runnable.new("Test", [], []) {}

      Expect.call(runnable.hasRun).toBeFalse

      runnable.run()

      Expect.call(runnable.hasRun).toBeTrue
    }

    it.should("return null if no error was generated by the test") {
      var runnable = Runnable.new("Test Title", [], []) {}

      runnable.run()

      Expect.call(runnable.error).toEqual(null)
    }

    it.should("return the error generated by a test error") {
      var block = Fn.new { Fiber.abort("Test error!") }
      var runnable = Runnable.new("Test Title", [], [], block)

      runnable.run()

      Expect.call(runnable.error).toEqual("Test error!")
    }

    // TODO: Enable after supporting better equals for complex objects.
    it.should("return the expectations generated by the test").skip {
      var expectation = Expectation.new(true, "Fail")
      var runnable = Runnable.new("Test", [], []) { expectation }

      runnable.run()

      Expect.call(runnable.expectations).toEqual([expectation])
    }
  }
}
